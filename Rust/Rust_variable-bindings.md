# 変数束縛(Variable Bindings)

変数束縛は値を名前に束縛し、あとでその値を使える  
let が束縛を導入するのに使われる

```
普通、束縛というときは名前 を 値 へ と束縛しますが、このドキュメントでは逆になっています。  
Rustでは他の言語と違って1つの値に対して1つの名前が対応するのであえてこう書いてるのかもしれません
```

```rust
func main() {
    let x = 5;
}
```

## パターン

`let` の左側の式はパターンであって、ただの変数ではない  
つまり、こういうことができる

```rust
let (x, y) = (1, 2)
```

パターン式が評価された後、x は 1 になり、y は 2 になる

## 型アノテーション

Rust は静的な型付言語だが、型推論が効く場合は型を書く必要はない

型を書く場合は下記のようにコロン(:)の後に書く

```rust
let x: i32 = 5;
```

Rust には多くのプリミティブな整数型がある  
プリミティブな整数型は符号付き型は i 、符号無し型は u から始まる  
整数型として可能なサイズは8、16、32、64bit

## 可変性

束縛はデフォルトでイミュータブル(不変)  

下記コードはコンパイルが通らない

```rust
let x = 5;
x = 10;
```

このようなエラーが出る

```
error[E0384]: re-assignment of immutable variable `x`
  --> src/main.rs:15:5
   |
14 |     let x = 5;
   |         - first assignment to `x`
15 |     x = 10;
   |     ^^^^^^ re-assignment of immutable variable
```

ミュータブル(可変)な束縛を作る時は `mut` を付ける

```rust
let mut x = 5;
x = 10;
```

束縛がデフォルトでイミュータブルなのは、Rust の主要な焦点、安全性の一環  
変更するつもりじゃないものをコンパイルエラーで教えてくれる  
本当に変更したい場合は `mut` を付ければいい

## 束縛を初期化

束縛を使う前に初期化されている必要がある

```rust
fn main() {
  let x: i32;
  println!("Hello, World!");
}
```

この場合は、x を使用していないという警告は出るがエラーにはならない

```rust
fn main() {
  let x: i32;
  println!("The value of x is {}", x);
}
```

この場合、x が未初期化なのでエラーになる  
このように Rust では未初期化の値を使うことは許されていない

`println!` に入れた「{}」を Rust は何かの値を入れてくれ(interpolate、インターポレート)という要求だと解釈する  
単純に `{}` を使った場合、Rust はインターポレートされる値の型を調べて意味のある方法で表示しようとする  
フォーマットを細かく指定したい場合はオプションを指定する

## スコープとシャドーイング

束縛にはスコープがある  
束縛は定義されたブロック内でしか有効じゃない

以下の例では `x` は `fn main() {}` ブロック内でアクセス可能だが、`y` は内側のブロックからのみアクセス可能

```rust
fn main() {
  let x: i32 = 17;
  {
    let y: i32 = 3;
    println!("The value of x is {} and value of y is {}", x, y);
  }
  println!("The value of x is {} and value of y is {}", x, y); // これは動かない
}
```

2つ目の `println!` は `y` がスコープにないためアクセスできないのでコンパイルエラーになる

加えて、束縛は覆い隠すことができる(これをシャドーイングという)  
つまり後から出てくる同じ名前の束縛があるとそれがスコープに入り、以前の束縛を上書きする

```rust
fn main() {
  let x: i32 = 8;
  {
    println!("{}", x); // 8
    let x = 12;
    println!("{}", x); // 12
  }
  println!("{}", x); // 8
  let x = 42;
  println!("{}", x); // 42
}
```

シャドーイングとミュータブルな束縛はコインの表と裏のように見えるが  
それぞれ独立な概念で互いに代用できないケースがある  
その1つにシャドーイングは同じ名前に違う型の値を再束縛することができる

```rust
fn main() {
  let mut x: i32 = 1;
  x = 7;
  let x = x; // x はイミュータブルになって 7 に束縛された
  
  let y = 4;
  let y = "I can also be bound to text!"; // y は違う型になった
}
```
