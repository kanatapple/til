# ライフタイム

所有権は Rust の最も独特で注目されている機能  
所有権は Rust の最大の目標であるメモリ安全性を得るための方法なので高度に精通しておくべき

## 概論

Rustは安全性とスピードに焦点を合わせます。 Rustはそれらの目標をたくさんの「ゼロコスト抽象化」を通じて成し遂げます。それは、Rustでは抽象化を機能させるためのコストをできる限り小さくすることを意味します。 所有権システムはゼロコスト抽象化の主な例です。 このガイドの中で話すであろう解析の全ては コンパイル時に行われます 。 それらのどの機能に対しても実行時のコストは全く掛かりません。

しかし、このシステムはあるコストを持ちます。それは学習曲線です。 多くの新しいRustのユーザは「借用チェッカとの戦い」と好んで呼ばれるものを経験します。そこではRustコンパイラが開発者が正しいと考えるプログラムをコンパイルすることを拒絶します。 所有権がどのように機能するのかについてのプログラマのメンタルモデルがRustの実装する実際のルールにマッチしないため、これはしばしば起きます。 しかし、よいニュースがあります。より経験豊富なRustの開発者は次のことを報告します。一度彼らが所有権システムのルールとともにしばらく仕事をすれば、彼らが借用チェッカと戦うことは少なくなっていくということです。

## ライフタイム

無効なリソースを指す参照はダングリングポインタ、または、解放後の使用と呼ばれる  
Rust の所有権システムはこれをライフタイムと呼ばれる概念を通じてチェックする  
それは参照の有効なスコープを記述するもの

引数として参照を受け取る関数について、参照のライフタイムを暗黙的、明示的に指定することができる

```rust
// 暗黙的に
fn foo(x: &i32) {
}

// 明示的に
fn bar<'a>(x: &'a i32) {
}
```

`'a` は「ライフタイムa」と読む  
技術的には参照は全てそれに関するライフタイムを持つが、一般的な場合にはコンパイラがそれを省略してもいいように計らってくれる  
(つまり、省略できる)

```rust
fn bar<'a>() {}
```

ライフタイムはジェネリックパラメータの一種  
`<>` はライフタイムを宣言するために使われ、これは `bar` が1つのライフタイム `'a` を持つことを意味している  
もし2つの参照引数がある場合は以下のようになる

```rust
fn bar<'a, 'b>() {}
```

そして、引数リストでは名付けたライフタイムを使う

```rust
fn bar<'a>(x: &'a i32) {}
```

もし `&mut` 参照が欲しい場合は以下のように

```rust
fn bar<'a>(x: &'a mut i32) {}
```

`&mut i32` と `&'a mut i32` を比較するならば、それらは同じ  
「i32へのミュータブルな参照」とか「ライフタイム'aを持つi32へのミュータブルな参照」と読む

## structの中

参照を含む `struct` を使う時にも明示的なライフタイムを必要とする

```rust
struct Foo<'a> {
  x: &'a i32
}

fn main() {
  let y = &5; // これは let _y = 5; let y = &_y; と同じ
  let f = Foo { x: y };
  println!("{}", f.x);
}
```

関数と同じ方法で `struct` もライフタイムを持つことができる  
ここでライフタイムが必要なのは、`Foo` への全ての参照がそれの含む `i32` への参照より長い間有効にはならないことを保証する必要があるから

### implブロック

`Foo` に次のようなメソッドを実装してみる

```rust
struct Foo<'a> {
  x: &'a i32
}

impl<'a> Foo<'a> {
  fn x(&self) -> &'a i32 { self.x }
}

fn main() {
  let y = &5;
  let f = Foo { x: y };
  println!("{}", f.x());
}
```

`Foo` のライフタイムは `impl` 行で宣言する必要があり、関数の時のように `'a` は2回繰り返される  
つまり、`impl<'a>` はライフタイム `'a` を定義し、`Foo<'a>` はそれを使う

### 複数のライフタイム

もし複数の参照があれば、同じライフタイムを複数回使うことができる

```rust
impl<'a> Foo<'a> {
  fn x_or_y<'a>(x: &'a str, y: &'a str) -> &'a str {}
}
```

これは `x` と `y` が同じスコープで有効で、戻り値もそのスコープで有効であることを示している

もし、`x` と `y` に違うライフタイムを持たせたいのでれば、複数のライフタイムパラメータを使うことができる

```rust
impl<'a, 'b> Foo<'a, 'b> {
  fn x_or_y<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}
}
```

### スコープの考え方

ライフタイムについて考えるには、参照の有効なスコープを可視化することが重要

```rust
fn main() {
  let y = &5;     // -+ yがスコープに入る
                  //  |
                  //  |
                  //  |
}                 // -+ yがスコープから出る
```

`Foo` を追加するとこうなる

```rust
struct Foo<'a> {
  x: &'a i32
}

fn main() {
  let y = &5;            // -+ yがスコープに入る
  let f = Foo { x: y };  // -+ fがスコープに入る
                         //  |
                         //  |
                         //  |
}                        // -+ fとyがスコープから出る
```

`f` は `y` のスコープの中で有効なので全て動く

以下のコードは動かない

```rust
struct Foo<'a> {
  x: &'a i32
}

fn main() {
  let x;                    // -+ xがスコープに入る
                            //  |
  {                         //  |
    let y = &5;             // ---+ yがスコープに入る
    let f = Foo { x: y };   // ---+ fがスコープに入る
    x = &f.x;               //  | | ここでエラーが起きる
  }                         // ---+ fとyがスコープから出る
                            //  |
  println!("{}", x);        //  |
}                           // -+ xがスコープから出る
```

`f` と `y` のスコープは `x` のスコープより小さい  
しかし、`x = &f.x` を実行する時、`x` をスコープから外れた何かの参照にしてしまう

名前の付いたライフタイムはそれらのスコープに名前を与える方法

### 'static

「static」と名付けられたライフタイムは特別なライフタイム  
これは何かがプログラム全体に渡るライフタイムを持つことを意味している

```rust
fn main() {
  let x: &'static str = "Hello, world.";
}
```

文字列リテラルは `&'static` 型を持つ  
なぜなら、参照が常に有効だから  
それらは最終的なバイナリのデータセグメントに焼き付けられる

もう1つはグローバル

```rust
fn main() {
  static FOO: i32 = 5;
  let x: &'static i32 = &FOO;
}
```

これはバイナリのデータセグメントに `i32` を追加する

## ライフタイムの省略

Rust は関数本体では強力な型推論をサポートするが、関数のシグネチャの部分では引数の型がわかるように型推論が許されていない  
しかし、エルゴノミック(人間にとっての扱いやすさ)の理由により、「ライフタイムの省略」と呼ばれる第2の推論アルゴリズムがシグネチャに適用される  
その推論はライフパラメータだけを推論する

「入力ライフタイム」は関数の引数に関連するライフタイム  
「出力ライフタイム」は関数の戻り値に関連するライフタイム

ライフタイムを省略できるルールは以下の3つ
- 関数の引数の中の省略された各ライフタイムは互いに異なるライフタイムパラメータになる
- もし入力ライフタイムが1つだけならば、省略されたかどうかにかかわらず、そのライフタイムはその関数の戻り値の中の省略されたライフタイム全てに割り当てられる
- もし入力ライフタイムが複数あるが、その1つが &self 又は &mut self であれば、 self のライフタイムは省略された出力ライフタイム全てに割り当てられる

そうでない時は出力ライフタイムの省略はエラー
