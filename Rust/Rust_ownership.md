# 所有権

所有権は Rust の最も独特で注目されている機能  
所有権は Rust の最大の目標であるメモリ安全性を得るための方法なので高度に精通しておくべき

## 概論

Rustは安全性とスピードに焦点を合わせます。 Rustはそれらの目標をたくさんの「ゼロコスト抽象化」を通じて成し遂げます。それは、Rustでは抽象化を機能させるためのコストをできる限り小さくすることを意味します。 所有権システムはゼロコスト抽象化の主な例です。 このガイドの中で話すであろう解析の全ては コンパイル時に行われます 。 それらのどの機能に対しても実行時のコストは全く掛かりません。

しかし、このシステムはあるコストを持ちます。それは学習曲線です。 多くの新しいRustのユーザは「借用チェッカとの戦い」と好んで呼ばれるものを経験します。そこではRustコンパイラが開発者が正しいと考えるプログラムをコンパイルすることを拒絶します。 所有権がどのように機能するのかについてのプログラマのメンタルモデルがRustの実装する実際のルールにマッチしないため、これはしばしば起きます。 しかし、よいニュースがあります。より経験豊富なRustの開発者は次のことを報告します。一度彼らが所有権システムのルールとともにしばらく仕事をすれば、彼らが借用チェッカと戦うことは少なくなっていくということです。

## 所有権

Rust では変数束縛はある特性を持つ  
それは、束縛されているものの「所有権を持つ」ということ  
これは束縛がスコープから外れる時、Rust は束縛されているリソースを解放するだろうということ

```rust
fn foo() {
  let v = vec![1, 2, 3];
}
```

`v` がスコープに入る時、新しい `Vec<T>` が作られ、この場合、ベクタも3つの要素のためにヒープに割り当てる  
`foo()` の最後で `v` がスコープが外れる時、Rust はベクタに関するもの全てを取り除く。それがヒープ割り当てのメモリであっても  
これはスコープの最後で決定的に起こる

## ムーブセマンティクス

Rust は与えられたリソースに対する束縛が1つだけあるということを保証する  
例えば、もしベクタがあって、それを別の束縛に割り当てることができる

```rust
fn foo() {
  let v = vec![1, 2, 3];
  let v2 = v;
}
```

しかし、もしあとで `v` を使おうとするとエラーが出る

```rust
fn foo() {
  let v = vec![1, 2, 3];
  let v2 = v;
  println!("v[0] is {}", v[0]);
}
```

コンパイル結果
```
error[E0382]: use of moved value: `v`
 --> src/main.rs:5:18
  |
3 |   let v2 = v;
  |       -- value moved here
4 |
5 |   println!("{}", v[0]);
  |                  ^ value used here after move
```

もし、所有権を受け取る関数を定義して、引数として何かを渡した後でそれを使おうとすると同じようなエラーが起こる

```rust
fn main() {
  let v = vec![1, 2, 3];
  
  foo(v);
  
  println!("v[0] is {}", v[0]);
}

fn foo(v: Vec<i32>) {
}
```

コンパイル結果
```
error[E0382]: use of moved value: `v`
 --> src/main.rs:6:18
  |
4 |   foo(v);
  |       - value moved here
5 |
6 |   println!("{}", v[0]);
  |                  ^ value used here after move
```

所有権を何か別のものに転送する時、参照するものを「ムーブした」と言う

### 詳細

束縛をムーブした後ではそれを使うことができないということの理由は微妙だが重要

```rust
fn main() {
  let v = vec![1, 2, 3];
  let v2 = v;
}
```

最初の行はベクタオブジェクト `v` とそれを含むデータのためにメモリを割り当てる  
ベクタオブジェクトはスタックに保存され、ヒープに保存された内容(`[1, 2, 3]`)へのポインタを含む  
`v` を `v2` にムーブする時、`v2` のためにそのポインタのコピーを作る  
それは、ヒープ上のベクタの内容へのポインタ2つあることを意味する  
これはデータ競合を持ち込むことで Rust の安全性保証に違反する  
そのため、Rust はムーブを終えたあとの `v` の使用を禁止する

### Copy型

所有権が他の束縛にムーブされる時、元の束縛を使うことができない  
これの挙動を変更する Copy トレイトがある

```rust
fn main() {
  let v = 1;
  let v2 = v;
  println!("v is {}", v);
}
```

上記の `v` は `i32` で Copy トレイトを実装している  
これは `v` を `v2` に割り当てる時、データのコピーが作られることを意味する  
しかし、ムーブと違って後で `v` を使うことができる  
これは `i32` がポインタを持たず、コピーが完全コピーだから

全てのプリミティブ型は Copy トレイトを実装しているので所有権はムーブしない

```rust
fn main() {
  let a = 5;
  let _y = double(a);
  println!("{}", a);
}

fn double(x: i32) -> i32 {
  x * 2
}
```

上記のようにプリミティブ型(i32、boolean、・・)は Copy トレイトを実装しているのでエラーにならない

## 所有権を超えて

もし、全ての関数で所有権を返さなければいけないのであれば、以下のようになる

```rust
fn foo(v: Vec<i32>) -> Vec<i32> {
  // なんか処理
  
  // 所有権を返す
  v
}
```

これは非常に退屈だし、もっとたくさんの所有権を受け取っていたら、その分返す必要がある・・

これを解決するものとして Rust は借用という機能を提供する
