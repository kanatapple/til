# プリミティブ型

## ブーリアン型

bool  
true と false

## char型

1つの Unicode のスカラー値を表す  
char型はシングルクォートで作ることができる

```rust
fn main() {
  let x = 'x';
}
```

char型は他の言語と違い4バイト

## 数値型

符号あり・なし、固定長・可変長、浮動小数点数・整数などがある

数値リテラルがその型を推論させるものがなければデフォルトになる

```rust
fn main() {
  let x = 42;  // i32型
  let y = 1.0; // f64型
}
```

数値型はカテゴリとサイズという2つの部分からなる

### 符号あり・なし

符号なし(unsigned)型は `u` を使う  
符号あり型は `i` を使う(`i` は integer(整数)の頭文字)

### 固定長・可変長

固定長型は符号の後にビット長を指定する

可変長型は Rust が実行しているマシンのポインタのサイズに依存する型  
カテゴリとして「`size`」を使い、符号あり・なしの `isize` と `usize` の2種類がある

### 浮動小数点数型

`f32` と `f64` の2つがある  
IEEE-754 の単精度、倍精度少数点数に対応する

## 配列

Rust にも何かのシーケンスを表現するためのリスト型がある  
最も基本的なのは配列、固定長の同じ型の要素のリスト  
デフォルトで配列はイミュータブル

```rust
fn main() {
  let a = [1, 2, 3]; // a: [i32; 3]
  let mut m = [1, 2, 3]; // m: [i32; 3]
}
```

配列は `[T; N]` という型を持つ

配列の各要素を同じ値で初期化するための省略表現がある

```rust
fn main() {
  let a = [0; 20];
}
```

配列 `a` の要素の個数は `a.len()` で得られる

```rust
fn main() {
  let a = [1, 2, 3];
  println!("a has {} elements", a.len());
}
```

配列の特定の要素には添字記法でアクセスできる  
もし配列に含まれない添字を使おうとするとコンパイル時に警告が出る  
`warning: this expression will panic at run-time`

配列アクセスは実行時に境界チェックを行う

## スライス

「スライス」は他のデータ構造への参照(ビュー)  
スライスはコピーすることなく配列の要素への安全で効率的なアクセスを許すために便利  
スライスは直接作られるのではなく既存の変数束縛から作られる  
スライスは定義された長さを持ち、ミュータブルにもイミュータブルにもできる

### スライシング構文

```rust
fn main() {
  let a = [0, 1, 2, 3, 4];
  let complete = &a[..]; // aに含まれる全ての要素を持つスライス
  let middle = &a[1..4]; // 1、2、3のみを要素に持つスライス
}
```

スライスは `&[T]` の型を持つ
