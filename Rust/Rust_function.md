# 関数

Rust のプログラムには少なくとも1つの関数、main 関数がある

```rust
fn main() {
}
```

`fn` は「これは関数」ということを示している

引数を取る関数

```rust
fn print_number(x: i32) {
  println!("x is {}", x);
}
```

上記関数を使用する場合は以下のようにする

```rust
fn main() {
  print_number(5);
}

fn print_number(x: i32) {
  println!("x is {}", x);
}
```

引数の指定は `let` 宣言と同じように、引数の名前の後に「: 型」を記述する  
`let` 宣言と異なり、必ず引数の型を宣言する  
プログラムによる完全な型推論は可能だが、Haskell のようにそれを行っている言語でも、型を明示的にドキュメント化することがベストプラクティスであると提案されている  

引数は以下のようにする

```rust
fn add_one(x: i32) -> i32 {
  x + 1
}
```

Rust の関数はただ1つの値を返す  
`->` のあとにその型を宣言する

上記関数の最後にセミコロンがないのは正しい  
これは Rust が式ベースの言語であるのと、セミコロンが他の「波括弧とセミコロン」ベースの言語のセミコロンとは違っていることを表す

## 式対文

Rust は主として式ベースの言語  
文には2種類しかなく、それ以外は全て式

式と文の違いは、式は値を返すが、文は値を返さない  
文である `x + 1;` は値を返さないのでエラーになってしまう

Rust の2種類の文は、宣言文と式文のみ

### 宣言文

Rust の変数束縛するための `let` は式ではないので、以下はエラーになる

```rust
let x = (let y = 5);
```

`let` は式ではなく文の先頭にしかなれない

次のことに注意  
すでに束縛されている変数(例えば、y = 5)への割り当ては式になる  
割当てが割り当てられる値(例えば、前の例では5)を評価する他の言語とは異なり、Rust では割当ての値は空のタプル()   
なぜなら、割り当てられる値には単一の所有者しかおらず、他のどんな値を返したとしても予想外の出来事になってしまうから

```rust
fn main() {
  let mut y = 5;
  let x = (y = 6);  // xは値 `()` を持っており、 `6` ではありません
}
```

### 式文

式文の目的は式を文に変換すること  
Rust の文法は文の後には文が続くことが期待されている  
これはそれぞれの式を区切るためにセミコロンを使うことを意味している

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}
```

この関数は `i32` を返そうとしているが、セミコロンを付けると `()` を返す

## 早期リターン

Rust は早期リターンのために `return` キーワードを持っている

```rust
fn foo(x: i32) -> i32 {
  return x;
  
  x + 1  // このコードは走らない
}
```

`return` を関数の最後の行で使っても動くが、よくないスタイルだと考えられている

```rust
fn foo(x: i32) -> i32 {
  return x + 1;
}
```

## ダイバージング関数

Rust はリターンしない関数、「ダイバージング関数」のための特別な構文を持っている

```rust
fn diverges() -> ! {
    panic!("This function never returns!");
}
```

`panic!` は現在のスレッドを与えられたメッセージとともにクラッシュさせる  
この関数はクラッシュを引き起こすので決してリターンしない  
そのため、「ダイバージ」と読む `!` 型を持つ

ダイバージング関数は任意の型して使うことができる

```rust
let x: i32 = diverges();
let x: String = diverges();
```

## 関数ポインタ

関数を指示する変数束縛を作ることもできる

```rust
let f: fn(i32) -> i32;
```

`f` は `i32` 型の引数を受け取り、`i32` 型の値を返す関数を指示する変数束縛

```rust
fn plus_one(i: i32) -> i32 {
  i + 1
}

// with type interface
let f: fn(i32) -> i32 = plus_one;

// without type interface
let f = plus_one;
```

その関数を使うのに `f` を使うことができる

```rust
let six = f(5);
```

