# 参照と借用

所有権は Rust の最も独特で注目されている機能  
所有権は Rust の最大の目標であるメモリ安全性を得るための方法なので高度に精通しておくべき

## 概論

Rustは安全性とスピードに焦点を合わせます。 Rustはそれらの目標をたくさんの「ゼロコスト抽象化」を通じて成し遂げます。それは、Rustでは抽象化を機能させるためのコストをできる限り小さくすることを意味します。 所有権システムはゼロコスト抽象化の主な例です。 このガイドの中で話すであろう解析の全ては コンパイル時に行われます 。 それらのどの機能に対しても実行時のコストは全く掛かりません。

しかし、このシステムはあるコストを持ちます。それは学習曲線です。 多くの新しいRustのユーザは「借用チェッカとの戦い」と好んで呼ばれるものを経験します。そこではRustコンパイラが開発者が正しいと考えるプログラムをコンパイルすることを拒絶します。 所有権がどのように機能するのかについてのプログラマのメンタルモデルがRustの実装する実際のルールにマッチしないため、これはしばしば起きます。 しかし、よいニュースがあります。より経験豊富なRustの開発者は次のことを報告します。一度彼らが所有権システムのルールとともにしばらく仕事をすれば、彼らが借用チェッカと戦うことは少なくなっていくということです。

## 借用

所有権の最後で問題になった関数

```rust
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
  // v1とv2についての作業を行う
  
  // 所有権と関数の結果を返す
  (v1, v2, 42)
}

fn main() {
  let v1 = vec![1, 2, 3];
  let v2 = vec![1, 2, 3];
  
  let (v1, v2, answer) = foo(v1, v2);
}
```

これは借用の利点を活かしてないので Rust 的なコードではない

```rust
fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
  // v1とv2についての作業を行う
  
  // 関数の結果を返す
  42
}

fn main() {
  let v1 = vec![1, 2, 3];
  let v2 = vec![1, 2, 3];
  
  let answer = foo(v1, v2);
  
  // これ以降でも v1 と v2 が使える
}
```

引数として `Vec<i32>` を使う代わりに、参照 `&Vec<i32>` を使う  
そして、`v1` と `v2` を直接渡す代わりに `&v1` と `&v2` を渡す  
`&T` 型は参照と呼ばれ、リソースを所有するのではなく、所有権を借用する  
借用した束縛はスコープが外れる時にリソースを割り当て解除しない  
これは `foo()` の呼び出しの後に元の束縛を再び使用できることを意味する

参照は束縛と同じようにイミュータブル  
以下はエラーになる

```rust
fn foo(v: &Vec<i32>) {
  v.push(5);
}

fn main() {
  let v = vec![];
  foo(&v);
}
```

## &mut参照

参照には2つ目の種類として `&mut T` がある  
ミュータブルな参照によって借用しているリソースを変更することができる

```rust
fn main() {
  let mut x = 5;
  {
    let y = &mut x;
    *y += 1;
  }
  println!("{}", x); // 6
}
```

`x` も `mut` とマークしなければいけないのは、イミュータブルな値へのミュータブルな借用となってしまうから  
`y` が `&mut` 参照だから、参照の内容にアクセスするためにアスタリスクをつける

前述の例で `{}` スコープを追加しているが、これを外すとエラーになる

```
error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
 --> src/main.rs:5:18
  |
3 |     let y = &mut x;
  |                  - mutable borrow occurs here
4 |     *y += 1;
5 |   println!("{}", x);
  |                  ^ immutable borrow occurs here
6 | }
  | - mutable borrow ends here
  ```

なぜなら、ルールがあるから

## ルール

Rust での借用のルール

- 借用は全て所有者のスコープより長く存在してはならない
- 次の2種類の借用のどちらか1つを持つことはあるが、両方を持つことはない
  - 複数のイミュータブルな参照(`&T`)
  - ただ1つのミュータブルな参照(`&mut T`)

これはデータ競合の定義と非常に似ている

```
「データ競合」は2つ以上のポインタがメモリの同じ場所に同時にアクセスするとき、少なくともそれらの1つが書込みを行っていて、作業が同期されていないところで「データ競合」は起きます。
```

書き込みを行わないのであれば、参照は好きな数だけ使うことができる  
`&mut` は同時に1つしか持つことができないのでデータ競合が起きない  
これが Rust がデータ競合をコンパイル時に回避する方法

### スコープの考え方

```rust
fn main() {
  let mut x = 5;
  let y = &mut x;
  
  *y += 1;
  
  println!("{}", x);
}
```

上記コードはルール違反しているのでエラーになる  
`y` が `x` を指す `&mut T` を持っているので、同時に `&T` を作ることが許されない(`println!`？)  
どちらか1つ

上記の例ではミュータブルな借用が残りの間ずっと保持されている  
必要なのは `println!` でイミュータブルな借用を作ろうとする前に ミュータブルな借用が終わること  
Rust では借用はその有効なスコープと結び付けられる

上記コードのスコープは以下のように見える

```rust
fn main() {
  let mut x = 5;
  
  let y = &mut x;    // -+ xの&mut借用がここから始まる
                     //  |
  *y += 1;           //  |
                     //  |
  println!("{}", x); // -+ - ここでxを借用しようとする
                     // -+ xの&mut借用がここで終わる
}
```

スコープが衝突するので `y` がスコープにある間は `&x` を作ることができない

波括弧を追加すると以下のようになる

```rust
fn main() {
  let mut x = 5;
  
  {
    let y = &mut x; // -+ &mut借用がここから始まる
    *y += 1;        //  |
  }                 // -+ ... そしてここで終わる
  
  println!("{}", x);// <- ここでxを借用しようとする
}
```

ミュータブルな借用はイミュータブルな借用を作る前にスコープから外れる

### 借用が回避する問題

これらの厳格なルールはデータ競合を回避するためにある  
データ競合はどのような種類の問題を起こすのか例を示す

#### イテレータの無効

繰り返し行なっているコレクションを変更しようとする時に起こる  
Rust の借用チェッカはこれの発生を回避する

```rust
fn main() {
  let mut v = vec![1, 2, 3];

  for i in &v {
    println!("{}", i);
    v.push(32);
  }
}
```

ベクタに対して繰り返す時、要素の参照だけを受け取る  
`v` はイミュータブルとして借用され、それは繰り返しを行っている間は変更できないことを意味する  
`v` はループによって借用されるので変更できない


1つのデータに対して複数の参照を持つことが出来、コピーを減らすことが出来る  
Rust の主要な売りの1つが参照をいかに安全に簡単に使えるか
