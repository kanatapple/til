# 型と宣言

## 名前

C++言語と標準ライブラリでは、型に対して小文字を使っている

## スコープ

### 局所スコープ

関数の中、ラムダ式の中で宣言された名前は `局所名` と呼ばれる  
スコープは、宣言箇所からその宣言を含むブロック終端まで

### クラススコープ

クラスの中で関数、ラムダ式、クラス、列挙クラスの外で定義された名前は `メンバ名` と呼ばれる  
スコープは、クラス宣言の開始の `{` から終了の `}` まで

### 名前空間スコープ

名前空間内の中で関数、ラムダ式、クラス、列挙クラスの外で定義された名前は `名前空間メンバ` と呼ばれる  
スコープは、宣言箇所から名前空間の終端まで

### 広域スコープ

あらゆる関数とクラス、列挙クラス、名前空間の外で定義された名前は `広域名` と呼ばれる  
スコープは、宣言箇所からその宣言を含むファイルの終端まで  
広域名前空間は、技術的に名前空間の一種とみなせるので、名前空間のメンバの１つとなる

### 文スコープ

`for` 、 `while` 、 `if` 、 `switch` の `()` の中で定義された名前は `文スコープ` と呼ばれる  
スコープは宣言箇所からその文の終端まで  
文スコープの名前はすべて局所名

### 関数スコープ

ラベルのスコープはその関数本体の全体

---
ブロック内で名前を宣言すると、そのブロックを囲む宣言や広域名の宣言を隠す  
すなわち、同じ名前をブロック内での別の実体を表すものとして再定義できる  
ブロックを抜けると最初の方の定義の意味が戻る

```c++
int x;              // 広域のx
void f() {
    int x;          // 局所のxは広域のxを隠す
    x = 1;         // 局所のxへの代入
    {
        int x;      // 最初の局所のxを隠す
        x = 2;    // 2番目の局所のxへの代入
    }
    x = 3;        // 最初の局所のxへの代入
}
int *p = &x;   // 広域のxのアドレスを取得
```

隠されてる広域変数は、 `スコープ解決演算子::` を使うとアクセスできる

```c++
int x;
void f() {
    int x = 1;
    ::x = 2;    // 広域のxへの代入
    x = 2;     // 局所のxへの代入
}
```

隠されている局所名にアクセスする方法はない

---

クラスメンバではない名前のスコープは宣言箇所から始まる  
そのため、宣言された名前は、自分自身の初期値としても利用できる

```c++
int x = 97;
void f() {
    int x = x;  // xを自分自身の値で初期化
}
```

スコープ解決演算子を使うことなく2つの異なるオブジェクトを参照するものとして、同じ名前をブロック内で利用することも可能

```c++
int x = 11;
void f() {
    int y = x;    // 広域xを代入。y = 11
    int x = 22;
    y = x;         // 局所xを代入。y = 22
}
```

ちなみに、for文内で定義された名前は文スコープとなるので、1つの関数の中でよく使われる名前のループ変数は何度でも利用できる

```c++
void f(vector<string> &v, list<int> &lst) {
    for (const auto &x : v) cout << x << '\n';
    for (auto x : lst) cout << x << '\n';
    for (int i = 0; i != v.size(); ++i) cout << v[i] << '\n';
    for (auto i : {1, 2, 3, 4, 5, 6, 7}) cout << i << '\n';
}
```

## 型別名

```c++
using int32_t = int;
typedef int int32_t;
```

末尾の `_t` は伝統的に `typedef` によって与えられた別名を意味する

別名に対して `unsigned` などの型指定子を適用することはできない

```c++
using Char = char;
using Uchar = unsigned Char; // エラー
using Uchar = unsigned char; // OK
```
