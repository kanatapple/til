# ポインタと配列と参照

## はじめに

オブジェクトは名前を使って参照する  
C++のほとんどオブジェクトが `アイデンティティを持つ`  
`アイデンティティを持つ` = 名前で参照する、ポインタで指す、参照で参照する

## ポインタ

型を `T` とした時、`T*`の型は、`Tへのポインタ`である  
そのため、`T*`型の変数は、`T`型オブジェクトのアドレスを保持できる

```c++
char c = 'a';
char *p = &c; // pはcのアドレスを保持。&はアドレス演算子
```

ポインタに対する基本的な演算は`参照外し`  
これはポインタが指すオブジェクトを参照することであり、`間接参照`とも呼ばれる  
参照外し演算子は、前置の単項演算子`*`である

```c++
char c = 'a';
char *p = &c;
char c2 = *p; // c2 == 'a'。*は参照外し演算子
```

### void*

型が不明なオブジェクトへのポインタ  
任意の型のオブジェクトを指すポインタは `void*` 型の変数に代入可能だが、関数へのポインタとメンバへのポインタは例外  
`void*` を他の `void*` に代入したり、`void*` 同士の等価判定、他の型への明示的な型変換も可能  
それ以外の演算は安全ではない(コンパイラは参照先のオブジェクトの型がわからないから)

```c++
void f(int *pi) {
  void *pv = pi;  // OK: int * から void * への暗黙の変換
  *pv;                 // エラー: void * は参照外しできない
  ++pv;              // エラー: void * はインクリメントできない(参照先のオブジェクトの大きさが不明)
  
  int *pi2 = static_cast<int *>(pv);  // OK: 明示的な型変換
  
  double *pd1 = pv;                                       // エラー
  double *pd2 = pi;                                        // エラー
  double *pd3 = static_cast<double *>(pv);  // 安全ではない
}
```

一般的に、ポインタが指すオブジェクトの型が異なる型への変換は安全ではない  
明示的な型変換は本質的に危険である上に見苦しいので、コードの中でわざと目立たせるように `static_cast` という概念が設計されて生み出された

#### 主な用途
- 引数のオブジェクト型を仮定しない関数に引数を与えること
- 型を持たないオブジェクトを返却値とする関数で使うこと

上記のような場合、オブジェクトを利用する時は明示的な型変換が必要

`void*` を利用する関数は、実際のハードウェア資源を操作するなどシステムのもっとも低いレベルに位置することが多い  
もし、システムの高レベルな場所で `void*` が利用されてたら、そのシステムは疑うべき

### nullptr
`nullptr` リテラルは、空ポインタ、すなわちオブジェクトを指さないポインタ  
あらゆるポインタ型に代入できるが、組み込み型への代入はできない

```c++
int *pi = nullptr;
doubld *pd = nullptr;
int i = nullptr; // エラー: i はポインタではない
```

nullptr は各ポインタ型ごとに存在する訳ではなく、あらゆるポインタ型で利用される

nullptr 導入前は、空ポインタは ゼロ(０) で表していた
```c++
int *x = 0;
```
0番地のアドレスにはオブジェクトは何も割り当てられていないため

かつては、空ポインタを表現するマクロ `NULL` を定義することが普及していた
```c++
int *p = NULL;
```
NULL の定義は処理系によって違いがあり、C言語では NULL を `(void *)0` と定義することが多いが、C++では認められていない
```c++
int *p = NULL; // エラー: int * に void * は代入できない
```

## 配列

`T` を型とすると、`T[size]` は `size個の型Tの要素を持つ配列` となる  
各要素の添字は、 0 から size - 1 まで

```c++
float v[3];     // 3個のfloat型で構成される配列。v[0] ～ v[2]
char *a[32];  // 32個のcharへのポインタで構成される配列。a[0] ～ a[31]
```

配列要素へのアクセスは、添字演算子[] かポインタを利用する

```c++
void f() {
  int aa[10];
  aa[6] = 9;
  int x = a[99]; // 定義されない動作
}
```

配列の範囲外にアクセスした際の動作は定義されていない  
実行時の範囲チェックは保証されていないし、行われない

配列(newで確保したものは除く)の要素数は定数式で指定しなければならない  
要素数が可変である配列が必要な場合は、`vector` を利用する

```c++
void f(int n) {
  int v1[n]; // エラー: 要素数が定数式ではない
  vector<int> v2(n); // OK
}
```

C++の組み込み配列は、低レベル機能で標準ライブラリの vector や array などの実装の内部で利用されるもの

配列の一種でもっとも広く利用されてるのが、ゼロで終端する char の配列  
これはC言語で文字列を保持する方法で、ゼロで終端する char の配列は `C言語スタイルの文字列` と呼ばれる  
C++での文字列リテラルもこの規約にしたがっていて、それ前提の標準ライブラリもあり、`char *` や `const char *` は、ゼロで終端する文字の並びを指すものと想定することが多い

### 配列の初期化

配列は値の並びを与えることで初期化できる

```c++
int v1[] = { 1, 2, 3, 4 };
char v2[] = { 'a', 'b', 'c', 0 };
```

要素数を指定せずに初期化子並びを与えて配列を宣言すると、初期化子並びの個数が配列の要素数になる  
要素数を明示的に指定し、初期化子並びの個数の方を大きくするとエラーになる

```c++
char v3[2] = { 'a', 'b', 0 }; // エラー
char v4[3] = { 'a', 'b', 0 }; // OK
```

逆に初期化子並びの個数が小さい時は、不足要素に対して `0` が埋められる

```c++
int v5[8] = { 1, 2, 3, 4 };  // ↓と一緒
int v5[8} = { 1, 2, 3, 4, 0, 0, 0, 0 };
```

配列に対する組み込みのコピー演算子は存在しない  
別の配列をもとに配列を初期化するのは不可能であり、配列の代入演算も存在しない

```c++
int v6[8] = v5; // エラー
v6 = v5;        // エラー
```

同様に配列を値渡しすることもできない

オブジェクトの集合を代入する必要がある場合は、`vector`、`array`、`valarray` を利用する

## 文字列リテラル

文字列リテラルは二重引用符記号で囲んだ文字の並び  
`"this is a string"`

文字列リテラルは見た目より1個だけ多くの文字を保持する  
それは終端を表すための値が `0` である `ナル文字 '\0'` の分

```c++
sizeof("Bohr") == 5
```

文字列リテラルの型は、 `適切な個数の const な文字の配列` である  
そのため、ここでの `"Bohr"` は `const char[5]型` である

```c++
char *p = "Plato"; // エラー
p[4] = 'e';        // エラー
```

変更可能な文字列が必要ならば、非constの配列に文字を置くといい

```c++
char p[] = "Zeno";
p[0] = 'R';
```

文字列リテラルは静的に割り当てられるので、関数の返却値として安全に利用できる

```c++
const char* error_message(int i) {
  return "range_error";
}
```

上記の `"range_error"` を保持するメモリ領域は `error_message()` の実行終了後も存在する

同じ綴りの文字列リテラルが2個存在する場合、配列を1個だけ割り当てて共有するか、別々の配列とするかは処理系定義

```c++
const char *p = "Heraclitus";
const char *q = "Heraclitus";
void g() {
  if (p == q) cout << "one!\n"; // 結果は処理系定義
}
```

`""` は空文字列を表し、その型は `const char[1]型` である  
その1個の文字は `'\0'` である

非グラフ文字を逆斜線で表す記法は文字列の中でも利用できる  

```c++
cout << "beep at end of message\a\n";
```

改行文字そのものを文字列リテラルに含めることはできない

```c++
"this is not a string
but a syntax error"
```

長い文字列は空白文字列で分割できるので、うまく使えば可読性が向上する

```c++
char alpha[] = "abcdefg"
               "ABCDEFG";
```

コンパイラは隣接した文字列を連結するので、`alpha` は以下のように1個の文字列を記述した場合と等価

```c++
char alpha[] = "abcdefgABCDEFG";
```

文字列リテラルにナル文字が含まれることもあるが、ナル文字の後に文字があることを想定するプログラムはあまりない  
例えば、`"Jens\000Munk"` という文字列は、標準ライブラリ関数では `"Jens"` として処理される

### 原文字列

文字列リテラル内で、逆斜線(\)や二重引用符(")を表す際は、これらの文字の直前に逆斜線を付与する  

```c++
string s = "\\w+\\\\\\w+";
```

上記のようなごちゃごちゃした表記によるエラーや不満を解消するために、C++では原文字列リテラル(raw string literal)が提供されている  
原文字列リテラルは逆斜線をそのまま逆斜線で表記する(二重引用符も)文字列リテラル

```c++
string s = R"(\w+\\\w+)";
```

`ccc` という文字の並びを原文字列で表現する場合、`R"(ccc)"` と表記する  
このように、先頭の`R`によって区別する  
また、丸括弧によって二重引用符がそのまま記述できる

```c++
R"("quoted string")"
```

`"(` と `)"` はデフォルトの区切り文字のペア  
`"(...)"` の中では任意の区切り文字を、`(` の直前と、`(` の直後に追加できる

```c++
R"***("quoted string")***"
```

また、原文字列リテラルには改行も含むことができる

```c++
string counts {R"(1
22
333)"};
// 以下と一緒
string counts {"1\n22\n333"};
```

## 配列の内部を指すポインタ

配列の名前は、その先頭要素を指すポインタとして利用できる

```c++
int v[] = { 1, 2, 3, 4 };
int *p1 = v;     // 先頭要素へのポインタ(暗黙の変換)
int *p2 = &v[0]; // 先頭要素へのポインタ
int *p3 = v + 4; // 末尾要素の1個後ろへのポインタ
```

末尾要素の1個後ろの要素を指すポインタを取り出す作業は、正常に行えるという保証がある  
なお、先頭要素より前方、末尾要素の1個後ろの要素より後方のアドレスを得る動作の結果は定義されない

```c++
int *p4 = v - 1;
int *p5 = v + 7;
```

配列名から、その先頭要素を指すポインタへの暗黙の変換は、C言語の関数呼び出しで広く用いられている

```c++
extern "C" int strlen(const char*);
void f() {
  char v[] = "Annemarie";
  char *p = v; // char[]からchar*への暗黙の変換
  strlen(p);
  strlen(v);
  v = p; // エラー：配列への代入はできない
}
```

関数呼び出しで配列全体を渡すような関数宣言構文は存在しない  
配列を引数として渡す際に暗黙裏にポインタに変換されることは、呼び出された関数で配列の要素数を取得できないことを意味する  
標準ライブラリのvector、array、stringでは `size()` で要素数が得られる

### 配列の操作

アクセスは、配列の先頭要素を指すポインタに対して添字を加えることによっても行えるし、要素自体を指すポインタによっても行える

```c++
void fi(char v[]) {
  for (int i = 0; i < v[i] != 0; i++) {
    use(v[i]);
  }
}
void fp(char v[]) {
  for (char *p = v; p != 0; p++) {
    use(*p);
  }
}
```

前置*演算子はポインタが指す先の参照外しを行うので、`*p` の記述によって、p が指す文字が得られる  
`++` はポインタをインクリメントするので、配列内の次の要素を指すことになる  
2種類のアクセス方法に実質的な速度差はない(現在のコンパイラだと同じコードを生成するはず)

ポインタに対する`+`、`-`、`++`、`--`の算術演算の結果は、ポインタが指すオブジェクトの型によって異なる  
型が`T*`であるポインタ`p`に対して算術演算を実行すると、`p`は配列内のT型のオブジェクトの要素を指すものと仮定される  
`p+1`の整数値は、`p`の整数値よりも`sizeof(T)`だけ大きくなる

```c++
template<typename T>
int byte_diff(T *p, T *q) {
  return reinterpret_cast<char *>(q) - reinterpret_cast<char *>(p);
}

void diff_test() {
  int vi[10];
  short vs[10];
  cout << vi << ' ' << &vi[1] << ' ' << &vi[1] - &vi[0] << ' ' << byte_diff(&vi[0], &vi[1]) << '\n';
  cout << vs << ' ' << &vs[1] << ' ' << &vs[1] - &vs[0] << ' ' << byte_diff(&vs[0], &vs[1]) << '\n';
}
```

ポインタの値は、デフォルトで16進表記で表示される  
ポインタ同士の減算は、両ポインタが同じ配列内の要素を指す場合にのみ定義される  
ポインタに整数を加算する演算と減算する演算はいずれも可能で、結果はポインタ値である  
結果のポインタが、演算前のポインタと同じ配列内の要素を指さなければ、結果は定義されない

```c++
void f() {
  int v1[10];
  int v2[10];
  int i1 = &v1[5] - &v1[3]; // i1 = 2
  int i2 = &v1[5] - &v2[3]; // 定義されない
  int *p1 = v2 + 2; // p1 = &v2[2];
  int *p2 = v2 - 2; // 定義されない
}
```

配列は、その要素数が一緒に保持されている保証がない  
配列は、終端となる目印を持たないので、配列を操作する際は、何らかの手段で要素数を与える必要がある

```c++
void fp(char v[], int size) {
  for (int = 0; i != size; i++)
    use(v[i]);
  for (int x : v)
    use(x);  // エラー：範囲for文はポインタに対して動かない
  
  const int N = 7;
  char v2[N];
  for (int i = 0; i != N; i++)
    use(v2[i]);
  for (int x : v2)
    use(x);  // 範囲for文は、要素数が既知の配列に対しては動く
}
```

標準ライブラリの`array`は、組み込み配列の利点を多く持つとともに、組み込み配列の欠点をほとんど持たない  

### 多次元配列

多次元配列は配列の配列として表現する

```c++
int ma[3][5];
```

配列 `ma` は5個のintで構成される配列が3個あるものとしてアクセスできる  
しかし、内部的には単なる15個のintにすぎない

配列の協会を表すのにコンマを利用する言語があるが、C++でコンマは順次演算子なのでありえない

```c++
int bad[3,5]; // エラー
int good[3][5];
```

### 配列の受け渡し

配列は、丸ごと値渡しされるのではなく、先頭要素を指すポインタとして受け渡しが行われる

```c++
void comp(double arg[10]) { // argはdouble*
  for (int i = 0; i != 10; i++)
    arg[i] += 99;
}

void f() {
  double a1[10];
  double a2[5];
  double a3[100];
  comp(a1);
  comp(a2); // 危険
  comp(a3); // 先頭の10個の要素のみを利用
}
```

`comp()` は次のように記述しても等価である

```c++
void comp(double *arg) {
  for (int = 0; i != 10; i++) {
    arg[i] += 99;
  }
}
```

関数の引数に配列を与えると、先頭の次元は単なるポインタとみなされ、配列の境界は単純に無視される  
要素の並びをその個数を表す情報とともに引数に与えるようなことは組み込みの配列では行えない

各次元の要素数がコンパイル時にわかってる場合は問題ない
